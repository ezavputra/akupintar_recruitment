// Generated by dts-bundle v0.7.3

export class TenantModule {
    constructor();
    /**
      *
      * @param namespace
      * @param accesscode
      */
    validateTenant(namespace: string, accessCode: string): Promise<boolean>;
}

export class UserModule {
        /**
            *
            */
        constructor();
        /**
                    *
                    * @param username
                    * @param password
                    */
        login(username: string, password: string): Promise<UserRecord>;
        /**
            *
            * @param email
            */
        forgetPassword(email: string): Promise<boolean>;
        /**
            *
            * @param oldPassword
            * @param newPassword
            */
        changePassword(oldPassword: string, newPassword: string): Promise<boolean>;
        getCurrentUser(): Promise<UserRecord>;
        /**
            *
            * @param loadMore
            * @returns
            */
        GetChatUsers(loadMore: boolean): Promise<UserRecord[]>;
        /**
            *
            * @returns
            */
        LogOutUser(): Promise<string>;
        /**
            *
            * @param profileStatus
            * @param imageFile
            * @returns
            */
        UpdateUser(profileStatus: string, imageFile: File): Promise<UserRecord>;
        /**
            *
            * @param availability
            * @returns
            */
        setUserAvailability(availability: string): Promise<boolean>;
}

export class ChatModule {
        constructor();
        /**
            *
            * @param recipientId
            */
        createThread(recipientId: string): Promise<string>;
        /**
            *
            * @param threadId
            * @returns
            */
        getThread(threadId: string): Promise<ThreadRecord>;
        /**
            *
            * @param threadId
            * @param message
            */
        sendMessage(threadId: string, message: Message): Promise<MessageRecord>;
        /**
            * @param records
            */
        sendMultipleMessages(records: Array<MessageRecord>): Promise<MessageRecord[]>;
        /**
            * @param action
            * @param appUserId
            */
        blockUnblockUser(action: string, appUserId: string): Promise<string>;
        /**
            *
            */
        InitializeQueue(): Promise<true>;
        /**
            * name
            */
        msgReadStatus(messageRecord: MessageRecord, messageStatus: MessageStatus): void;
        /**
            *
            * @param threadId
            */
        getMessages(threadId: string): Promise<MessageRecord[]>;
        /**
         *
         * @param threadId
         * @param list
         * @param isFavorite
         */
        markAsFavorite(list: Array<MessageRecord>, isFavorite: boolean): Promise<true>;
        /**
            *
            */
        getAllFavoriteMessages(chatHistoryRequest: ChatHistoryRequest): Promise<MessageHistories>;
        /**
            *
            * @param threadId
            */
        getAllFavoriteMessagesByThreadId(threadId: string): Promise<MessageRecord[]>;
        /**
            *
            * @param threadId
            * @param reaction
            */
        sendReaction(threadId: string, reaction: Reaction): Promise<ChatReactionRecord>;
        /**
            *
            * @param deletedChat
            */
        deleteChat(deletedChat: DeleteMessage): Promise<boolean>;
        /**
            *
            * @param chatHistoryRequest
            * @returns
            */
        messageHistory(chatHistoryRequest: ChatHistoryRequest): Promise<MessageHistories>;
        /**
            *
            * @param chatHistoryRequest
            * @returns
            */
        FollowThreads(chatHistoryRequest: ChatHistoryRequest): Promise<MessageHistories>;
        /**
            *
            * @param threadId
            * @param searchText
            */
        searchMessageHistory(threadId: string, searchText: string, searchType: string, skip: string, limit: string): Promise<UnifiedSearchResult>;
        /**
            *
            * @param threadId
            * @param searchText
            */
        searchLocalMessageHistory(threadId: string, searchText: string): Promise<MessageRecord[]>;
        /**
            *
            * @param updateMessage
            */
        updateMessage(updateMessage: UpdateMessage): Promise<boolean>;
        /**
            *
            * @param threadType
            * @param skip
            * @param limit
            * @param fetchAll
            */
        threadHistory(threadType: string, skip: string, limit: string, fetchAll: boolean): Promise<ThreadHistory[]>;
        /**
            *
            * @returns ChatSettings
            */
        chatSettings(): Promise<ChatSettings>;
        /**
            *
            * @param appUserId
            * @returns ChatUserRecord
            */
        LoginIntoChatServer(appUserId: string): Promise<ChatUserRecord>;
        getMessageFromLocalStorage(messsegeId: string): Promise<MessageRecord>;
}

export class FCMModule {
        /**
            *
            */
        constructor();
        /**
            *
            * @param payload
            */
        onMessageReceived(payload: any): void;
        /**
            *
            * @param payload
            */
        clearNotification(payload: any): void;
        /**
            *
            * @param token
            * @param appUserId
            */
        registerFCMToServer(token: string, appUserId: string): void;
}

export class GroupChatModule {
        /**
            *
            */
        constructor();
        /**
            *
            * @returns
            */
        getGroups(): Promise<GroupRecord[]>;
        /**
            *
            * @param id
            * @returns
            */
        getGroupById(id: string): Promise<GroupRecord>;
        /**
            *
            * @param groupRecord
            * @param groupImage
            * @returns
            */
        createGroup(groupRecord: GroupRecord, groupImage: File): Promise<GroupRecord>;
        /**
            *
            * @param groupId
            * @param groupName
            * @param groupDescription
            * @param groupImage
            * @param groupType
            * @returns
            */
        updateGroup(groupId: string, groupName: string, groupDescription: string, groupImage: File, groupType: string): Promise<GroupRecord>;
        /**
            *
            * @param groupId
            * @param users
            * @returns
            */
        addParticipants(groupId: string, users: string[]): Promise<GroupRecord>;
        /**
            *
            * @param groupId
            * @param users
            * @returns
            */
        removeParticipants(groupId: string, users: string[]): Promise<GroupRecord>;
        /**
            *
            * @param groupId
            * @param user
            * @returns
            */
        addAdmin(groupId: string, user: string): Promise<GroupRecord>;
        /**
            *
            * @param groupId
            * @param user
            * @returns
            */
        removeAdmin(groupId: string, user: string): Promise<GroupRecord>;
        /**
            *
            * @param groupId
            * @returns
            */
        exitGroup(groupId: string): Promise<GroupRecord>;
        /**
            *
            * @param groupId
            * @returns
            */
        removeGroupPic(groupId: string): Promise<string>;
}

export var EventManager: any;

export class TypingModule {
        /**
            *
            */
        constructor();
        /**
            * name
            */
        typingStatus(typingRecord: TypingIndicatorRecord): void;
}

export class ChatReportModule {
        constructor();
        /**
            *
            * @param createChatReportRequest
            * @returns
            */
        CreateChatReport(createChatReportRequest: CreateChatReportRequest): Promise<string>;
        /**
            *
            * @param updateChatReportRequest
            * @returns
            */
        UpdateChatReport(updateChatReportRequest: CreateChatReportRequest): Promise<string>;
        /**
            *
            * @param chatReportId
            * @returns
            */
        DeleteChatReport(chatReportId: string): Promise<boolean>;
        /**
            *
            * @param chatReportId
            * @returns
            */
        ChatReportById(chatReportId: string): Promise<ChatReport>;
        /**
            *
            * @param threadId
            * @param category
            * @param status
            * @param msgType
            * @param skip
            * @param limit
            * @returns
            */
        ChatReportList(threadId: string, category: string, status: string, msgType: string, skip: string, limit: string): Promise<ChatReport[]>;
        /**
            *
            * @param chatReportId
            * @param action
            * @returns
            */
        ResolveReport(chatReportId: string, action: string): Promise<string>;
}

export class eRTCSDK {
    constructor();
    /**
      * Package name
      * @param packageName
      */
    initialise(packageName: string): void;
}

export interface UserRecord extends ChatUserRecord {
        Id?: string;
        loginType?: string;
        profilePic?: string;
        profilePicThumb?: string;
        profileStatus?: string;
        loginTimeStamp?: number;
        availabilityStatus?: string;
        blockedStatus?: string;
        role?: string;
        isBot?: boolean;
}
export interface ChatUserRecord {
        name?: string;
        tenantId?: string;
        UserChatId?: string;
        ertcId?: string;
}
export interface GroupUserRecord {
        UserChatId?: string;
        ertcId?: string;
        role?: string;
        joinedAtDate?: string;
}
export interface MessageRecord {
        id: string;
        tenantId?: string;
        timestamp?: number;
        message?: string;
        read?: number;
        threadType?: string;
        threadId?: string;
        status?: string;
        msgType?: string;
        senderId?: string;
        mediaPath?: string;
        mediaThumbnail?: string;
        mediaName?: string;
        locationRecord?: LocationSchema;
        contactName?: string;
        phoneContactRecord?: Array<NumberContactSchema>;
        emailContactRecord?: Array<EmailContactSchema>;
        isFavoriteMessage?: boolean;
        isEdited?: boolean;
        isDeleted?: boolean;
        gifPath?: string;
        senderRecord?: ChatUserRecord;
        chatThreadMetadata?: ChatThreadMetadata;
        chatEventType?: ChatEventType;
        forwardChatdata?: ForwardChatdata;
        reactionData?: Array<ChatReactionsData>;
        hasChildThreads?: boolean;
        customData?: any;
        follow?: boolean;
        chatReportId?: string;
        chatReportStatus?: string;
}
export interface MessageHistories {
        total?: number;
        messages?: MessageRecord[];
}
export interface ChatReactionsData {
        emojiCode?: string;
        userRecord?: ChatUserRecord[];
        count?: number;
}
export interface ForwardChatdata {
        parentMsgId?: string;
        isForwarded?: boolean;
}
export interface ChatThreadMetadata {
        parentMsgId?: string;
        parentMsg?: string;
        chatThreadCount?: number;
        sendToChannel?: number;
        participants?: ChatUserRecord[];
}
export enum ChatEventType {
        INCOMING = "incoming",
        OUTGOING = "outgoing",
        CHAT_META_DATA = "chat_meta_data"
}
export interface TypingIndicatorRecord {
        threadId?: string;
        typingStatus?: string;
        threadType?: string;
        userId?: string;
        name?: string;
}
export enum MessageType {
        Text = "text",
        Contact = "contact",
        Location = "location",
        Image = "image",
        Audio = "audio",
        Video = "video",
        Sticker = "sticker",
        File = "file",
        Smile = "smile",
        Gify = "gify",
        Gif = "gif"
}
export enum MessageStatus {
        NONE = "none",
        SENDING = "sending",
        UPLOADING = "uploading",
        SENT = "sent",
        DELIVERED = "delivered",
        SEEN = "seen",
        FAILED = "failed"
}
export interface IertcError {
        errorCode?: string;
        message?: string;
}
export class ertcError implements IertcError {
        errorCode?: string;
        message?: string;
        /**
            *
            */
        constructor(errorCode: string, message: string);
}
export interface GroupRecord {
        groupId?: string;
        tenantId?: string;
        threadId?: string;
        name?: string;
        groupType?: string;
        loginType?: string;
        groupPic?: string;
        groupThumb?: string;
        groupDesc?: string;
        loginTimestamp?: number;
        groupUsers?: GroupUserRecord[];
        freeze?: boolean;
        deactivated?: boolean;
}
export enum ChatType {
        SINGLE = "single",
        GROUP = "group",
        CHAT_THREAD = "chat_thread",
        SINGLE_CHAT_THREAD = "single_chat_thread",
        GROUP_CHAT_THREAD = "group_chat_thread"
}
export interface Message {
        msgCorrelationId?: string;
        message?: string;
        parentMsgId?: string;
        sendToChannel?: number;
        media?: File;
        gifPath?: string;
        contact?: Contact;
        location?: LocationSchema;
        chatType?: ChatType;
        type?: MessageType;
        mentions?: MentionType;
        mentioned_users?: Array<string>;
        isForwarded?: boolean;
        forwardedMsgId?: string;
        forwardedMedia?: ForwadedMediaSchema;
}
export interface ForwadedMediaSchema {
        path: string;
        thumbnail: string;
        name: string;
}
export interface MessageMetaData {
        reaction?: Reaction;
}
export interface Reaction {
        msgId: string;
        parentMsgId?: string;
        sendToChannel: number;
        emojiCode: string;
        chatReactionType?: ChatReactionType;
}
export interface ChatReactionRecord {
        threadId?: string;
        msgUniqueId?: string;
        emojiCode?: string;
        chatReactionType?: ChatReactionType;
        userRecord?: ChatUserRecord[];
        count?: number;
        parentMsgId?: string;
}
export interface ChatReactionEvent {
        threadId?: string;
        msgUniqueId?: string;
        emojiCode?: string;
        chatReactionType?: ChatReactionType;
        userRecord?: ChatUserRecord;
        count?: number;
        parentMsgId?: string;
}
export interface Contact {
        contactName?: string;
        phoneNumberRecord?: Array<NumberContactSchema>;
        eMailRecords?: Array<EmailContactSchema>;
}
export enum ChatReactionType {
        SET = "set",
        CLEAR = "clear"
}
export enum MentionType {
        CHANNEL = "channel",
        HERE = "here"
}
export interface MsgReadStatus {
        /**
            * Unique identified tenant
            */
        tenantId?: string;
        /**
            * Unique identified of chat object generated by server
            */
        id?: string;
        /**
            * Unique identified Thread
            */
        threadId?: string;
        /**
            * User's eRTCUserId who published this topic
            */
        ertcId?: string;
        /**
            * Message status event type : delivered/seen
            */
        status?: string;
        /**
            * Message status event time stamp
            */
        timeStamp?: number;
        /**
            * Chat Metadata for thread chat
            */
        chatThreadMetadata?: ChatThreadMetadata;
}
export interface DeleteMessage {
        threadId?: string;
        msgCorrelationId?: string;
        msgIds: string[];
        deleteType: string;
}
export interface UpdateMessage {
        threadId?: string;
        msgId?: string;
        message?: string;
        isFavoriteMessage?: boolean;
        follow?: boolean;
        chatThreadMetadata?: ChatThreadMetadata;
}
export interface ThreadRecord {
        threadId?: string;
        threadType?: string;
        tenantId?: string;
        createdAt?: number;
        participants?: Array<ChatUserRecord>;
        user?: ChatUserRecord;
        group?: GroupRecord;
}
export interface ThreadHistory {
        thread?: ThreadRecord;
        lastMessage?: MessageRecord;
}
export interface CreateChatReportRequest {
        chatId: string;
        category?: string;
        reason?: string;
}
export interface ChatReportStatus {
        status?: string;
        createdAt?: number;
}
export interface ChatReport {
        tenantId?: string;
        chatReportId?: string;
        category?: string;
        reason?: string;
        channelAdminStatus?: ChatReportStatus;
        tenantAdminStatus?: ChatReportStatus;
        reporterUser?: ChatUserRecord;
        chat?: MessageRecord;
}
export interface ChatHistoryRequest {
        threadId?: string;
        threadType?: string;
        follow?: boolean;
        pagesize?: number;
        direction?: string;
        currentMsgId?: string;
        includeCurrent?: boolean;
        replyChatId?: string;
        fetchAll?: boolean;
        messageTypes?: string[];
        deep?: boolean;
        starred?: boolean;
        includeDeleted?: boolean;
}
export interface ChatSettings {
        /**
            * Tenant id
            */
        tenantId?: string;
        /**
            * List of profanity filters
            */
        profanityFilter?: any;
        /**
            * List of domain filters
            */
        domainFilter?: any;
}
export interface EventList {
        eventType: string;
}
export interface FCMFrozen {
        groupId: string;
        threadId: string;
        eventList: EventList[];
}
export interface UnifiedSearchResult {
        messages?: MessageRecord[];
        files?: MessageRecord[];
        channels?: GroupRecord[];
        totalMessages?: number;
        totalFiles?: number;
        totalChannels?: number;
}

/**
    * Get Chat User
    */
export interface GetUserRequest {
        appUserId?: string;
        deviceId?: string;
        deviceType?: string;
        fcmToken?: string;
        publicKey?: string;
        muteSetting?: string;
}
export interface E2eEncryptionKeys {
        keyId: string;
        deviceId: string;
        publicKey: string;
        eRTCUserId: string;
}
export interface Token {
        accessToken: string;
        refreshToken: string;
        expiresIn: number;
}
export interface UserResult {
        eRTCUserId: string;
        appUserId: string;
        tenantId: string;
        name: string;
        e2eEncryptionKeys: E2eEncryptionKeys[];
        token: Token;
}
export interface GetUserResponse extends ApiResponse {
        result: UserResult;
}
/**
    * Create Thread
    */
export interface ThreadRequest {
        /**
            * eRTC user id of source user
            */
        sendereRTCUserId?: string;
        /**
            * App user Id of receiver
            */
        recipientAppUserId?: string;
}
export interface ThreadResult {
        /**
            * App user Id of receiver
            */
        recipientAppUserId?: string;
        /**
            * Thread ID
            */
        threadId?: string;
        /**
            * Type of thread - single/group
            */
        threadType?: string;
        /**
            * Tenant ID
            */
        tenantId?: string;
        /**
            * Therad object creation time
            */
        createdAt?: number;
        participants?: Array<ThreadMemberSchema>;
        e2eEncryptionKeys?: E2eEncryptionKeyList;
}
export interface E2eKeyObj {
        /**
            * Key identifier.
            */
        keyId?: string;
        /**
            * Device identifier.
            */
        deviceId?: string;
        /**
            * public Key of associated device
            */
        publicKey?: string;
        /**
            * user eRTCUserId.
            */
        eRTCUserId?: string;
}
export interface ThreadMemberSchema {
        /**
            * eRTC user Id of member
            */
        user?: string;
        notificationSettings?: NotificationSettings;
}
export interface E2eEncryptionKeyList extends Array<E2eKeyObj> {
}
export interface NotificationSettings {
        /**
            * Allow from values. It can be all/mentions/none. When it is include in thread response,
            * can have value just for requesting used.
            */
        allowFrom?: string;
}
export interface ThreadResponse extends ApiResponse {
        result: ThreadResult;
}
export interface E2eKeyObjWithReturnCodee {
        /**
            * Key identifier.
            */
        keyId?: string;
        /**
            * Device identifier.
            */
        deviceId?: string;
        /**
            * public Key of associated device
            */
        publicKey?: string;
        /**
            * user eRTCUserId.
            */
        eRTCUserId?: string;
        /**
            * Return code associated with individual key object. It can be receiverKeyNotActive / receiverKeyInvalid
            */
        returnCode?: string;
}
export interface ChatStatusSchema {
        /**
            * return code for e2e encrypted chat request. It can be senderKeyValidityExpired (new key to be provided in keyList, also new device key if there) / receiverKeyValidationError / senderNewDeviceKeyAvailable (new device key to be provided in keyList, also same device key if validity expired) / success
            */
        returnCode?: string;
        /**
            * Boolean parameter which indicates if same chat needs to be re-sent after resolving issues based on returnCode
            */
        retryRequired?: boolean;
        /**
            * list of key details based on returnCode. Details of this list depends on returnCode.
            */
        keyList?: Array<E2eKeyObjWithReturnCodee>;
}
export interface ReplyThreadSchemaChatResponse {
        /**
            * msgUniqueId of base chat
            */
        baseMsgUniqueId?: string;
        /**
            * Reply config which applies to reply chat. For example, bit 0 is used to decide whether to show reply on window or not.
            */
        replyMsgConfig?: number;
        numOfReplies?: number;
}
export interface ChatRequestObj {
        /**
            * Thread Id. This is exclusive peer to recipientAppUserId.
            */
        threadId?: string;
        /**
            * App user Id of receiver. This is exclusive peer to threadId.
            */
        recipientAppUserId?: string;
        /**
            * eRTC user id of source user
            */
        sendereRTCUserId?: string;
        /**
            * message text
            */
        message?: string;
        /**
            * message type. it can be text/contact/location/gify
            */
        msgType?: string;
        contact?: ContactSchema;
        location?: LocationSchema;
        /**
            * gify URL
            */
        gify?: string;
        /**
            * JSON object which can be used for client reference in request/response context. Server will not do any processing on this object. eg. { \"abc\" : \"def\" }
            */
        metadata?: any;
        replyThreadFeatureData?: ReplyThreadSchemaChatRequest;
        forwardChatFeatureData?: ForwardChatSchemaChatRequest;
        mentions?: MentionsSchemaChatRequest;
        /**
            * Client generated unique identifier used to trace message delivery till receiver.
            */
        msgCorrelationId?: string;
        /**
            * epoch timestamp (in ms) of message creation generated on sender device
            */
        senderTimeStampMs?: number;
        /**
            * JSON object which can be used for customer specific data which is not supported in InAppChat chat model. eg. { \"abc\" : \"def\" }
            */
        customData?: any;
}
export interface ForwardChatSchemaChatRequest {
        /**
            * msgUniqueId of original chat
            */
        originalMsgUniqueId?: string;
        /**
            * to indicate if message is forwarded one or not.
            */
        isForwarded?: boolean;
}
export interface MentionsSchemaChatRequest extends Array<MentionSchema> {
}
export interface MentionSchema {
        type?: string;
        value?: string;
}
export interface CreateChatResult {
        /**
            * Unique identified of chat object generated by server
            */
        msgUniqueId?: string;
        /**
            * Thread Id
            */
        threadId?: string;
        /**
            * Tenant Id
            */
        tenantId?: string;
        /**
            * message type. It can be text/image/video/gif/audio
            */
        msgType?: string;
        /**
            * Chat object creation epoch time in miliseconds
            */
        createdAt?: number;
        /**
            * JSON object which can be used for client reference in request/response context. Server will not do any processing on this object.
            */
        metadata?: any;
        chatStatus?: ChatStatusSchema;
        replyThreadFeatureData?: ReplyThreadSchemaChatResponse;
        forwardChatFeatureData?: ForwardChatSchemaChatReceive;
        reactions?: Array<ReactionInChatHistorySchema>;
        contact?: ContactSchema;
        location?: LocationSchema;
        media?: MediaSchema;
        thread?: ThreadObj;
        gify?: string;
        /**
            * If chat message is starred
            */
        isEdited?: boolean;
        /**
            * If chat is starred
            */
        isStarred?: boolean;
        /**
            * JSON object which can be used for customer specific data which is not supported in InAppChat chat model. eg. { \"abc\" : \"def\" }
            */
        customData?: any;
        follow?: boolean;
        chatReportId?: string;
}
export interface CreateChatResponse extends ApiResponse {
        result: CreateChatResult;
}
export interface CreateMultiChatResponse extends ApiResponse {
        result: CreateChatResponse[];
}
export interface ChatUserDetailsRequest {
        /**
            * list of status keys needed in response. Must contain atleast one item.
            */
        statusKeys?: Array<string>;
        /**
            * appUserId list of chatUsers
            */
        appUserIds?: Array<string>;
}
export interface ChatUserDetailResult {
        /**
            * List of chatUser details
            */
        chatUserDetails?: Array<ChatUserDetailsSchema>;
}
export interface ChatUserDetailsSchema {
        /**
            * appUserId of user
            */
        appUserId?: string;
        /**
            * eRTC user ID of user
            */
        eRTCUserId?: string;
        statusDetails?: ChatUserDetailsSchemaStatusDetails;
}
export interface ChatUserDetailsSchemaStatusDetails {
        /**
            * Availability status i.e. online/away/invisible/dnd
            */
        availabilityStatus?: string;
        /**
            * blocked status i.e. blocked. if this field does not, means unblocked
            */
        blockedStatus?: string;
}
export interface ChatUserDetailsResponse extends ApiResponse {
        result: ChatUserDetailResult;
}
export interface MsgReadStatusEventPublish {
        /**
            * Unique identified tenant
            */
        tenantId?: string;
        /**
            * Unique identified of chat object generated by server
            */
        msgUniqueId?: string;
        /**
            * Sender eRTCUserId of message
            */
        sendereRTCUserId?: string;
        /**
            * Device Id
            */
        deviceId?: string;
        /**
            * Unique identified Thread
            */
        threadId?: string;
        /**
            * User's eRTCUserId who pubblished this topic
            */
        eRTCUserId?: string;
        /**
            * Message status event type : delivered/seen
            */
        msgStatusEvent?: string;
        /**
            * Message status event time stamp
            */
        timeStamp?: number;
        replyThreadFeatureData?: ReplyThreadSchemaChatRequest;
}
export interface ReplyThreadSchemaChatRequest {
        /**
            * msgUniqueId of base chat
            */
        baseMsgUniqueId?: string;
        /**
            * Reply config which applies to reply chat. For example, bit 0 is used to decide whether to show reply on window or not.
            */
        replyMsgConfig?: number;
}
export interface MsgReadStatusEventSubscribe {
        /**
            * Unique identified tenant
            */
        tenantId?: string;
        /**
            * Unique identified of chat object generated by server
            */
        msgUniqueId?: string;
        /**
            * Unique identified Thread
            */
        threadId?: string;
        /**
            * User's eRTCUserId who pubblished this topic
            */
        eRTCUserId?: string;
        /**
            * Message status event type : delivered/seen
            */
        msgStatusEvent?: string;
        /**
            * Message status event time stamp
            */
        timeStamp?: number;
        replyThreadFeatureData?: ReplyThreadSchemaChatRequest;
}
export interface TypingStatusEventPublish {
        /**
            * Unique identified tenant
            */
        tenantId?: string;
        /**
            * Array of thread participant eRTCUserId except sender
            */
        participants?: Array<string>;
        /**
            * Unique identified Thread
            */
        threadId?: string;
        /**
            * User's eRTCUserId who pubblished this topic
            */
        eRTCUserId?: string;
        /**
            * Typing status event type : on/off
            */
        typingStatusEvent?: string;
        /**
            * Thread group : single/group
            */
        threadType?: string;
}
export interface TypingStatusEventSubscribe {
        /**
            * Unique identified tenant
            */
        tenantId?: string;
        /**
            * Unique identified Thread
            */
        threadId?: string;
        /**
            * User's eRTCUserId who pubblished this topic
            */
        eRTCUserId?: string;
        /**
            * Typing status event type : on/off
            */
        typingStatusEvent?: string;
        name?: string;
        msgCorrelationId?: string;
}
export interface AvailabilityStatusSubscribe {
        /**
            * eRTC user Id
            */
        eRTCUserId?: string;
        /**
            * User ID i.e. abc@def.com
            */
        appUserId?: string;
        /**
            * availability status of user. i.e. online/away/invisible/dnd
            */
        availabilityStatus?: string;
}
export interface ChatEventSubscribe {
        /**
            * Unique identified of chat object generated by server
            */
        msgUniqueId?: string;
        /**
            * Tenant Id
            */
        tenantId?: string;
        /**
            * message text. it can be present for any msgType value
            */
        message?: string;
        /**
            * message type. it can be text/image/audio/video/gif/file/contact/location
            */
        msgType?: string;
        contact?: ContactSchema;
        location?: LocationSchema;
        media?: MediaSchema;
        /**
            * gify URL
            */
        gify?: string;
        sender?: SenderInChatEventSubscribe;
        /**
            * Chat object creation epoch time in miliseconds
            */
        createdAt?: number;
        thread?: ThreadObj;
        encryptedChat?: EncryptedChatObj;
        replyThreadFeatureData?: ReplyThreadSchemaChatReceive;
        forwardChatFeatureData?: ForwardChatSchemaChatReceive;
        /**
            * If notification to be silent or not
            */
        isSilent?: boolean;
        /**
            * Client generated unique identifier used to trace message delivery till receiver.
            */
        msgCorrelationId?: string;
        /**
            * epoch timestamp (in ms) of message creation generated on sender device
            */
        senderTimeStampMs?: number;
        /**
            * JSON object which can be used for customer specific data which is not supported in InAppChat chat model. eg. { \"abc\" : \"def\" }
            */
        customData?: any;
}
export interface ForwardChatSchemaChatReceive {
        /**
            * msgUniqueId of original chat
            */
        originalMsgUniqueId?: string;
        /**
            * to indicate if message is forwarded one or not.
            */
        isForwarded?: boolean;
}
export interface ReplyThreadSchemaChatReceive {
        /**
            * msgUniqueId of base chat
            */
        baseMsgUniqueId?: string;
        /**
            * Reply config which applies to reply chat. For example, bit 0 is used to decide whether to show reply on window or not.
            */
        replyMsgConfig?: number;
        numOfReplies?: number;
}
export interface SenderInChatEventSubscribe {
        /**
            * eRTC user Id
            */
        eRTCUserId?: string;
        /**
            * User ID i.e. abc@def.com
            */
        appUserId?: string;
        /**
            * User name
            */
        name?: string;
}
export interface EncryptedChatObj {
        /**
            * Key identifier.
            */
        keyId?: string;
        /**
            * Device identifier.
            */
        deviceId?: string;
        /**
            * public Key of associated device
            */
        publicKey?: string;
        /**
            * user eRTCUserId.
            */
        eRTCUserId?: string;
        /**
            * encrypted message text. it can be present for any msgType value
            */
        message?: string;
        /**
            * encrypted stringified contact object. please check contactSchema for object value
            */
        contact?: string;
        /**
            * encrypted stringified location object. please check contactSchema for object value
            */
        location?: string;
        /**
            * gify URL
            */
        gify?: string;
        /**
            * encrypted media path URL
            */
        path?: string;
        /**
            * encrypted media thumbnail URL
            */
        thumbnail?: string;
}
export interface ThreadObj {
        /**
            * Thread ID
            */
        threadId?: string;
        /**
            * Type of thread - single/group
            */
        threadType?: string;
        /**
            * Tenant ID
            */
        tenantId?: string;
        /**
            * Therad object creation time
            */
        createdAt?: number;
        /**
            * array of read timestamps
            */
        participants?: Array<ThreadMemberSchema>;
}
export interface ContactSchema {
        /**
            * Name of contact
            */
        name?: string;
        /**
            * Contact Number
            */
        numbers?: Array<NumberContactSchema>;
        /**
            * Contact Email
            */
        emails?: Array<EmailContactSchema>;
}
export interface NumberContactSchema {
        /**
            * Type of Number contact. For example Home/Work
            */
        type?: string;
        /**
            * Contact Number
            */
        number?: string;
}
export interface EmailContactSchema {
        /**
            * Type of Email contact. For example Home/Work
            */
        type?: string;
        /**
            * Email
            */
        email?: string;
}
export interface LocationSchema {
        /**
            * Longitude
            */
        longitude?: number;
        /**
            * Latitude
            */
        latitude?: number;
        /**
            * Address of location
            */
        address?: string;
}
export interface MediaSchema {
        /**
            * media URL. use chatServer URL as prefix to generate complete URL
            */
        path?: string;
        /**
            * media thumbnail URL. It can be present for only media with msgType as 'image'. use chatServer URL as prefix to generate complete URL
            */
        thumbnail?: string;
        /**
            * original name of file uploaded
            */
        name?: string;
}
/**
    * Update User Request
    */
export interface UpdateUserRequest {
        deviceId?: string;
        deviceType?: string;
        fcmToken?: string;
        availabilityStatus?: string;
        notificationSettings?: NotificationSettings;
}
export interface UpdateUserResponse extends ApiResponse {
        result: UserResult;
}
export interface BlockUnblockUserRequest {
        appUserId?: string;
}
export interface BlockUnblockResult {
        message?: string;
}
export interface BlockUnblockUserResponse extends ApiResponse {
        result: BlockUnblockResult;
}
export interface ChatReactionAPIRequest {
        msgUniqueId: string;
        emojiCode: string;
        action: string;
        msgCorrelationId: string;
}
export interface ChatReactionAPIResult {
        msgUniqueId: string;
        emojiCode: string;
}
export interface ChatReactionAPIResponse extends ApiResponse {
        result: ChatReactionAPIResult;
}
export interface FcmMqttChatReaction {
        /**
            * User unique Identifier
            */
        eRTCUserId?: string;
        /**
            * Chat unique Identifier
            */
        msgUniqueId?: string;
        /**
            * Emoje code string
            */
        emojiCode?: string;
        /**
            * Reaction actionType. It can be set/clear
            */
        action?: string;
        /**
            * Total count of particular reaction with emojiCode
            */
        totalCount?: number;
        /**
            * Thread unique identifier
            */
        threadId?: string;
        /**
            * Tenant unique identifier
            */
        tenantId?: string;
        replyThreadFeatureData?: ReplyThreadSchemaChatRequest;
        /**
            * Client generated unique identifier used to trace message delivery till receiver.
            */
        msgCorrelationId?: string;
}
export interface LocalStorageChatReactionRecord {
        id?: string;
        threadId?: string;
        msgUniqueId?: string;
        emojiCode?: string;
        chatReactionType?: string;
        userRecord?: any[];
        count?: number;
        parentMsgId?: string;
}
export interface DeleteChatRequestObj {
        /**
            * List of chat objects to be deleted. Required.
            */
        chats?: Array<ChatObjIndeleteChatRequest>;
        /**
            * Thread Id. Required.
            */
        threadId?: string;
        /**
            * type of delete. supported values: self/everyone. Required.
            */
        deleteType?: string;
        /**
            * Client generated unique identifier used to trace message delivery till receiver.
            */
        msgCorrelationId?: string;
}
export interface ChatObjIndeleteChatRequest {
        /**
            * message unique ID
            */
        msgUniqueId?: string;
}
export interface DeleteChatResult {
        /**
            * List of deleted chats
            */
        chats?: Array<ChatObjIndeleteChatResponse>;
}
export interface ChatObjIndeleteChatResponse {
        /**
            * message unique ID
            */
        msgUniqueId?: string;
        message?: string;
        isStarred?: boolean;
        replyThreadFeatureData?: ReplyThreadSchemaChatRequest;
}
export interface DeleteChatResponse extends ApiResponse {
        result: DeleteChatResult;
}
export interface FcmMqttChatUpdate {
        /**
            * User unique Identifier
            */
        eRTCUserId?: string;
        /**
            * List of deleted chats
            */
        chats?: Array<ChatObjIndeleteChatResponse>;
        /**
            * Chat unique Identifier
            */
        msgUniqueId?: string;
        /**
            * Type of update. eg. delete/edit
            */
        updateType?: string;
        /**
            * Thread unique identifier
            */
        threadId?: string;
        /**
            * Tenant unique identifier
            */
        tenantId?: string;
        /**
            * Client generated unique identifier used to trace message delivery till receiver.
            */
        msgCorrelationId?: string;
        deleteType?: string;
}
export interface ChatInHistorySchema {
        /**
            * Unique identified of chat object generated by server
            */
        msgUniqueId?: string;
        /**
            * Tenant Id
            */
        tenantId?: string;
        /**
            * message text. it can be present for any msgType value
            */
        message?: string;
        /**
            * message type. it can be text/image/audio/video/gif/file/contact/location
            */
        msgType?: string;
        contact?: ContactSchema;
        location?: LocationSchema;
        media?: MediaSchema;
        /**
            * gify URL
            */
        gify?: string;
        /**
            * sender eRTCUserId
            */
        sendereRTCUserId?: string;
        /**
            * Chat object creation epoch time in miliseconds
            */
        createdAt?: string;
        replyThreadFeatureData?: ReplyThreadSchemaChatReceive;
        forwardChatFeatureData?: ForwardChatSchemaChatReceive;
        /**
            * list of reactions
            */
        reactions?: Array<ReactionInChatHistorySchema>;
        threadId?: string;
        /**
            * If chat message is starred
            */
        isEdited?: boolean;
        /**
            * If chat is starred
            */
        isStarred?: boolean;
        /**
            * JSON object which can be used for customer specific data which is not supported in InAppChat chat model. eg. { \"abc\" : \"def\" }
            */
        customData?: any;
        follow?: boolean;
        chatReportId?: string;
        chatReportStatus?: string;
        sender?: UserInThreadHistorySchema;
        isDeleted?: boolean;
}
export interface ReactionInChatHistorySchema {
        /**
            * Emoje code string
            */
        emojiCode?: string;
        /**
            * Emoje code string
            */
        count?: string;
        /**
            * List of eRTCUserIds
            */
        users?: Array<string>;
}
export interface ChatHistoryResult {
        /**
            * Total Chats in history under particular threadId.
            */
        total?: number;
        /**
            * List of history conversations
            */
        chats?: Array<ChatInHistorySchema>;
}
export interface ChatHistoryResponseSchema extends ApiResponse {
        result: ChatHistoryResult;
}
export interface ThreadMemberInHistorySchema {
        /**
            * eRTC user Id of member
            */
        eRTCUserId?: string;
        /**
            * appUserId of member
            */
        appUserId?: string;
        notificationSettings?: NotificationSettings;
}
export interface UserInThreadHistorySchema {
        /**
            * eRTC user Id of member
            */
        eRTCUserId?: string;
        /**
            * appUserId of member
            */
        appUserId?: string;
        /**
            * name of member
            */
        name?: string;
        /**
            * availability status of user. i.e. online/away/invisible/dnd
            */
        availabilityStatus?: string;
}
export interface GroupHighLevelDetails {
        /**
            * Group ID
            */
        groupId?: string;
        /**
            * Group Name
            */
        name?: string;
        /**
            * Type of group. for example privte/public. only private is supported as of now.
            */
        groupType?: string;
        /**
            * Profile pic url. use chatServer URL as prefix to generate complete URL
            */
        profilePic?: string;
        /**
            * Profile pic thumbnail url. use chatServer URL as prefix to generate complete URL
            */
        profilePicThumb?: string;
        /**
            * ThreadId associated with group. To be used for chat
            */
        threadId?: string;
        freeze?: Freeze;
}
export interface Freeze {
        enabled: boolean;
}
export interface ThreadObject {
        /**
            * Thread ID
            */
        threadId?: string;
        /**
            * Type of thread - single/group
            */
        threadType?: string;
        /**
            * Tenant ID
            */
        tenantId?: string;
        /**
            * Therad object creation time
            */
        createdAt?: number;
        /**
            * array of read timestamps
            */
        participants?: Array<ThreadMemberInHistorySchema>;
        user?: UserInThreadHistorySchema;
        group?: GroupHighLevelDetails;
}
export interface ThreadInHistorySchema {
        thread?: ThreadObject;
        lastMessage?: ChatInHistorySchema;
}
export interface ThreadHistoryResult {
        /**
            * Total conversations in history with matching threadType.
            */
        total?: number;
        /**
            * List of history conversations
            */
        threads?: Array<ThreadInHistorySchema>;
}
export interface ThreadHistorySchema extends ApiResponse {
        result: ThreadHistoryResult;
}
export interface UpdateChatRequest {
        /**
            * Chat unique Identifier
            */
        msgUniqueId?: string;
        /**
            * Thread Id. Required.
            */
        threadId?: string;
        /**
            * message text. it can be present for any msgType value
            */
        message?: string;
        /**
            * If message is starred
            */
        isStarred?: boolean;
        follow?: boolean;
}
export interface UpdateChat {
        msgUniqueId: string;
}
export interface UpdateChatResult {
        chat: UpdateChat;
}
export interface UpdateChatResponse extends ApiResponse {
        result: UpdateChatResult;
}
export interface ChatSearchQueryObj {
        /**
            * Query string. Reuiqred.
            */
        text?: string;
        /**
            * Thread Id if search target is particular thread. optional.
            */
        threadId?: string;
        channelQuery?: channelQuery;
}
export interface channelQuery {
        joined?: boolean;
        groupType?: string;
}
export interface ChatSearchRequest {
        searchQuery?: ChatSearchQueryObj;
        /**
            * Result category list
            */
        resultCategories?: Array<string>;
}
export interface ChatSearchResultCategoryObj {
        /**
            * Total Chats in history under particular threadId.
            */
        total?: number;
        /**
            * List of history conversations
            */
        chats?: Array<ChatInHistorySchema>;
        /**
            * List of threads
            */
        threads?: Array<ThreadResult>;
}
export interface UserGroupsResponse {
        /**
            * Group list list
            */
        groups?: Array<GroupHighLevelDetails>;
}
export interface UnifiedSearchResponse {
        messages?: ChatSearchResultCategoryObj;
        files?: ChatSearchResultCategoryObj;
        channels?: UserGroupsResponse;
}
export interface ChatSearchResponse extends ApiResponse {
        result: UnifiedSearchResponse;
}
export interface FcmMqttuserSelfUpdate {
        /**
            * User's eRTCUserId
            */
        eRTCUserId?: string;
        eventList?: Array<UserSelfUpdateEventItem>;
}
export interface UserSelfUpdateEventItem {
        /**
            * Type of the event. it can be availabilityStatusChanged/ notificationSettingsChangedGlobal/notificationSettingsChangedThread/userBlockedStatusChanged
            */
        eventType?: string;
        eventData?: any;
}
export interface UserSelfupdateEventData_ {
        /**
            * Optional. Thread id only applicable for notificationSettingsChangedThread
            */
        threadId?: string;
        notificationSettings?: NotificationSettings;
        /**
            * Optional. Only applicable for availabilityStatusChanged. Availability status i.e. online/away/invisible/dnd
            */
        availabilityStatus?: string;
}
export interface FcmMqttuserSelfUpdate {
        /**
            * User's eRTCUserId
            */
        eRTCUserId?: string;
        eventList?: Array<UserSelfUpdateEventItem>;
}
export interface FcmMqttAnnouncement {
        announcement: Announcement;
}
export interface Announcement {
        details: string;
        group: Group;
}
export interface Group {
        groupId: string;
        groupType: string;
        description: string;
        name: string;
}

export interface ApiResponse {
    success: boolean;
    msg: string;
    errorCode: string;
}

